#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 28 13:00:59 2020

@author: glenkiely99
"""
### This code propagates electrn beams through a sample, using a Monte Carlo algorithm to 
### generate scattering angles and step distances. 


import numpy as np
import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from decimal import *


error = []

#necessary constants
avo = 6.022e23 #avogadros number


#initialise the code
E0 = 100 #starting energy of electron in keV
E = E0
Z = 6 #atomic number of sample carbon
A = 12.011 #g/mol
rho = 2.26 #density of target g/cm3
no_of_steps = 5 #number of steps
thickness = 2e-5 #thickness of sample
e_min = 0.5 #cutoff energy in keV
beams = 10 #number of electron beams to propagate
d = 2e-9 #electron beam diameter - need to integrate a function of lambda / 2 sin theta

number_backscattered = 0
number_stopped = 0
number_transmitted = 0


#initialise the figure
fig = plt.figure()
ax = plt.axes(projection="3d")



#random number generating function
def RND(a = 0, b = 1):
    RND = random.uniform(a,b)
    return RND



#stopping power is used to calculate the energy lost at each step of propagation 
def stop_power(E, Z = 6):
    J = (9.76*Z + (58.5/Z**0.19)) * (1e-3) #mean ionisation potential keV
    #J should = 0.078 for carbon (Z = 6)
    J = 0.078
    print("J = " + str(J))
    stopping_power = -78500 * (Z/(A*E)) * np.log((1.166*(E + (0.85*J)))/J)
    return stopping_power #correct



#this is used to calculate the step length 
def elastic_mfp_alpha(E, Z = 6):
    alpha = ((0.0034*(Z**0.67))/E) #correct
    elastic_cross_sec = (5.21e-21) * ((Z**2)/(E**2)) * ((4 * math.pi) / (alpha*(1+alpha))) * (((E+511)/(E + 1024))**2) #correct
    elastic_mean_free_path = (A) / (avo * rho * elastic_cross_sec) 
    elastic_mean_free_path = elastic_mean_free_path / 100
    return elastic_mean_free_path, alpha #correct in cm or commented line for m!!!
    


#function of the mean free path above
def step_length(elastic_mean_free_path):
    random = RND()
    step = (- elastic_mean_free_path) * np.log( random ) 
    return step #correct in m



#to find initial positions and directional cosines 
def initialise_postions(E = E0, d = 2e-9): #d is diameter of electron probe in m.

    elastic_mean_free_path, alpha = elastic_mfp_alpha(E0)
    step = step_length(elastic_mean_free_path)
    print("step = " + str(step))
    
    
    #Gaussian intensity distribution along beam diameter
    mu, sigma = 0, 1e-9
    initrand = RND()
    randgauss = np.random.normal(mu, sigma, 1) 
    randgauss = randgauss[0]
    x0 = math.cos(math.pi * initrand) * randgauss * sigma
    y0 = math.sin(math.pi * initrand) * randgauss * sigma #divide by cos theta (specimen tilt) :) 
    z0 = math.sqrt(step**2 - x0**2 - y0**2 )
    #first scattering act - beam enters sample with zero angle (sin = 0 and cos = 1)
    #now determine scattering angle, defined by beam relative to coordinate axis
    vector_length = step
    cx = x0/vector_length
    cy = y0/vector_length
    cz = z0/vector_length
    print("cx = " + str(cx))
    print("cy = " + str(cy))
    print("cz = " + str(cz))
    print("equals to 1? = " + str(cx**2 + cy**2 + cz**2)) #works. 
    return np.array([cx, cy, cz, z0, y0, x0, step])



def scattering_angles(alpha):
    randcos = RND()
    print("randcos = " + str(randcos))
    cos_phi = 1 - ((2*alpha*randcos)/(1+alpha-randcos))
    sin_phi = math.sqrt(1-cos_phi**2)
    azi_scat_angle = 2 * math.pi * RND() #correct
    return cos_phi, sin_phi, azi_scat_angle



#perform a step in coordinates and change cosines
def coord_step(coords, cosines, step, E, alpha):
    x = coords[0]
    y = coords[1]
    z = coords[2]
    cx = cosines[0]
    cy = cosines[1]
    cz = cosines[2]
    print("cx = " + str(cx))
    print("cy = " + str(cy))
    print("cz = " + str(cz))
    #######################
    cos_phi, sin_phi, azi_scat_angle = scattering_angles(alpha)
    #######################
    print("cosphi = " + str(cos_phi))
    print("sinphi = " + str(sin_phi))
    print("azi angle = " + str(azi_scat_angle))
    #######################
    if cz == 0:
        cz = 0.000001
    AN = - (cx/cz) 
    AN2 = AN**2
    AM = 1 / (math.sqrt(1 + (AN*AN)))
    V1 = AN * sin_phi 
    V2 = AN * AM * sin_phi 
    V3 = math.cos(azi_scat_angle) 
    V4 = math.sin(azi_scat_angle) 
    #######################
    print("V1 = " + str(V1))
    print("V2 = " + str(V2))
    print("V3 = " + str(V3))
    print("V4 = " + str(V4))
    print("AM = " + str(AM))
    print("AN = " + str(AN))
    print("AN2 = " + str(AN2))
    #######################
    ca = (cx*cos_phi) + (V1*V3) + (cy*V2*V4) 
    cb = (cy*cos_phi) + (V4*( (cz*V1) - (cx*V2) )) 
    cc = (cz*cos_phi) + (V2*V3) - (cy*V1*V4) 
    addto = 1 - (ca**2 + cb**2 + cc**2)
    print("addto = " + str(addto))
    #if addto < 0:
        #addto = abs(addto)
        #addto = math.sqrt(addto)
        #ca = ca - (addto/2)
        #cb = cb - (addto/2)
    #else: 
        #addto = math.sqrt(addto)
        #ca += (addto/2)
        #cb += (addto/2)
    #######################
    print("ca = " + str(ca))
    print("cb = " + str(cb))
    print("cc = " + str(cc))
    print("adds up to 1? = " + str((ca**2) + (cb**2) + (cc**2))) #this should equal 1, why not???
    #######################
    xn = x + (step*ca)
    yn = y + (step*cb)
    zn = z + (step*cc)
    #######################
    coords = (xn, yn, zn)
    coordinate_history.append(coords)
    cosines = (ca, cb, cc)
    err = 1 - (ca**2 + cb**2 + cc**2)
    error.append(err)
    return coords, cosines



#loop for propagation
for i in range(beams): 
    print("********___________________________________********")
    E = E0
    initial_parameters = initialise_postions() #np.array([cx, cy, cz, z0, y0, x0, vector_length])
    coordinates = (initial_parameters[5],initial_parameters[4],initial_parameters[3])#initial coordinates
    #print(coordinates)
    cosines = (initial_parameters[0],initial_parameters[1],initial_parameters[2]) #initial cosines
    #print(cosines)
    coordinate_history = []
    coordinate_history.append(coordinates) 
    condition = True
    no_of_steps = 0
    

    while condition: #while condition is True
    #for i in range(no_of_steps - 1):
        print("_____________________________________________________STEP")
        z = coordinates[2]
        #print(z)
        if z < 0:
            condition = False
            number_backscattered += 1
        if E <= e_min:
            condition = False
            number_stopped += 1
        if z > thickness:
            condition = False
            number_transmitted += 1
        
        
        (elastic_mean_free_path, alpha) = elastic_mfp_alpha(E)
        step = step_length(elastic_mean_free_path)
        (coordinates, cosines) = coord_step(coordinates, cosines, step, E, alpha) #gets new coordinates for each loop
        
        stopping_power = stop_power(E)
        E_lost = (step * rho * stopping_power) #wrong by an order of 2 ~ 3?
        print("E_lost = " + str(E_lost))
        E = E + E_lost
        print("E = " + str(E))
        no_of_steps += 1
        
    print("no of steps = " + str(no_of_steps))
    x_coords = [i[0] for i in coordinate_history]
    y_coords = [i[1] for i in coordinate_history]
    z_coords = [i[2] for i in coordinate_history]
    #print(z_coords)
    colour = (round(RND(),2),round(RND(),2),round(RND(),2))
    ax.plot3D(x_coords, y_coords, z_coords, color = colour, linewidth = 0.9)

print("transmitted = " + str(number_transmitted))
print("stopped = " + str(number_stopped))
print("backscattered = " + str(number_backscattered))
plt.show()

def errorplot(error): #plots the increase in compounding error from 1-cosines**2 - constantly increases except for a few spikes
    x_vals = []
    delta = []
    for i in range(len(error)):
        x_vals.append(i)
        E2 = error[i]
        E1 = error[i-1]
        delta.append(E2 - E1)
    
    plt.plot(x_vals, delta)
    plt.show()
    
#for i in range(len(coordinate_history) - 1):
#    print(coordinate_history[i]) 



